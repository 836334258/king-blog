import{_ as t,r as o,o as p,c,a as n,d as s,e as l,b as a}from"./app.fc8d2037.js";const i="/king-blog/images/vue-1.webp",u="/king-blog/images/vue-2.webp",r={},d=n("h2",{id:"在最近的工作中-用原生的js比较多-有好几个项目都不是用vue写的-怕长久不用遗忘了vue-翻阅文档-想到的东西会写在这里",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#在最近的工作中-用原生的js比较多-有好几个项目都不是用vue写的-怕长久不用遗忘了vue-翻阅文档-想到的东西会写在这里","aria-hidden":"true"},"#"),s(" 在最近的工作中，用原生的js比较多，有好几个项目都不是用vue写的，怕长久不用遗忘了vue，翻阅文档，想到的东西会写在这里")],-1),k=a("<li><code>nextTick</code> 由于dom更新不是同步生效的，在修改dom里面的值后再取dom里面的值会导致数据不同步，在<code>nextTick</code>回调里面可以确保dom中的值已经更新，使用方法 <ul><li><code>await nextTick()</code></li><li><code>nextTick(fn)</code></li></ul></li><li>如果要在<code>setup</code>中使用<code>mixin</code>,可以使用<code>const {proxy}=getCurrentInstance();proxy.mixInFn()</code></li>",2),v=a('<li>响应式<strong>原理</strong>：当我们在调用响应式函数的时候，会把JavaScript对象包裹成响应式对象，对于<code>ref()</code>函数，当用到<code>ref.value</code>时，会触发<code>get value()</code>方法，此时会把<code>effect()</code>函数注册到全局的依赖地图<code>weakMap</code>中，这样当修改时，会触发set函数，然后在全局的依赖地图<code>weakMap</code>中找到注册的<code>effect()</code>函数并执行。结构就是<code>weakMap</code>-&gt;<code>map</code>-&gt;<code>set</code><img src="'+i+'" alt="vue-1"> <img src="'+u+`" alt="vue-2"></li><li><code>shallowRef()</code> 只会将对象表层转换成响应式对象，只有对 .value 的访问是响应式的，即不会递归的转为响应式</li><li><code>shallowReactive()</code> reactive() 的浅层作用形式。</li><li><code>triggerRef()</code> 强制触发依赖于一个浅层 ref 的副作用，这通常在对浅引用的内部值进行深度变更后使用。</li><li><code>readonly()</code> 将一个对象变为只读，底层是用proxy代理的对象，然后修改了proxy的<code>get</code> 、<code>set</code>、 <code>deleteProperty</code>方法，当调用<code>set</code>、 <code>deleteProperty</code>时直接返回<code>false</code></li><li><code>shallowReadonly()</code>readonly() 的浅层作用形式</li><li><code>toRaw()</code> 根据一个 Vue 创建的代理返回其原始对象 实现<strong>原理</strong>如下<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> proxyPerson<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">===</span><span class="token string">&#39;__v_raw1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> target
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">toRaw2</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">val</span><span class="token operator">:</span>any</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> val<span class="token punctuation">[</span><span class="token string">&#39;__v_raw1&#39;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>markRaw()</code>将一个对象标记为不可被转为代理。返回该对象本身。实现<strong>原理</strong>：为对象添加一个<code>__v_skip</code>属性，在即将代理对象时，会调用<code>getTargetType()</code>方法对对象里面的<code>__v_skip</code>属性进行判断，如果有的话就会直接返回对象</li><li><code>effectScope()</code>创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token keyword">const</span> counter<span class="token operator">=</span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> scope<span class="token operator">=</span><span class="token function">effectScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> <span class="token literal-property property">twoCounter</span><span class="token operator">:</span>any
  scope<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    twoCounter<span class="token operator">=</span><span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>counter<span class="token punctuation">.</span>value<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token function-variable function">change</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    counter<span class="token punctuation">.</span>value<span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> <span class="token function-variable function">stop</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  <span class="token comment">// 当调用stop事件后，当counter改变时，twoCounter将不再变化</span>
    scope<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>getCurrentScope()</code> 如果有的话，返回当前活跃的 effect 作用域。</li><li><code>isRef()</code> 检查某个值是否为 ref。<strong>原理</strong>：判断<code>__v_isRef</code>属性是否为true</li><li><code>unref()</code> 如果参数是 ref，则返回内部值，否则返回参数本身。 <strong>原理</strong>:<code>return isRef(ref) ? ref.value : ref;</code></li><li><code>toRef()</code> 可用于为响应式对象上的 property 创建 ref。这样创建的 ref 与其源 property 保持同步：改变源 property 将更新 ref，反之亦然 <strong>原理：</strong> 和<code>ref()</code>函数一样，直接调用<code>new ObjectRefImpl()</code></li><li><code>toRefs()</code> 将一个响应式对象转换为一个普通对象，这个普通对象的每个 property 都是指向源对象相应 property 的 ref。<strong>原理：</strong> 新建一个新对象，遍历响应式对象，新对象key为响应式对象的key，值为<code>toRef()</code>后的值</li><li><code>isProxy()</code> 检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理。 原理：<code>return isReactive(value) || isReadonly(value);</code></li><li><code>isReactive()</code> 检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理。原理：<code> return !!(value &amp;&amp; value[&quot;__v_isReactive&quot;]);</code></li><li><code>isReadonly()</code> 检查一个对象是否是由 readonly() 或 shallowReadonly() 创建的代理。 原理：<code> return !!(value &amp;&amp; value[&quot;__v_isReadonly&quot;]);</code></li><li><code>ref()</code>接受一个内部值，返回一个响应式的、可更改的 ref 对象</li><li><code>computed()</code> 接受一个 getter 函数，返回一个只读的响应式 ref 对象，即 getter 函数的返回值。它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。</li>`,19),m=n("code",null,"reactive()",-1),f=n("code",null,"ref",-1),g=n("code",null,".value",-1),y=n("code",null,"proxy",-1),b=n("code",null,"get",-1),_={href:"https://staging-cn.vuejs.org/api/reactivity-core.html",target:"_blank",rel:"noopener noreferrer"},w=a(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ref unwrapping - skip unwrap for Array + integer key.</span>
      <span class="token keyword">return</span> targetIsArray <span class="token operator">&amp;&amp;</span> <span class="token function">isIntegerKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">?</span> res <span class="token operator">:</span> res<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),h=a(`<li><code>readonly()</code> 接受一个对象 (不论是响应式还是一般的) 或是一个 ref，返回一个原值的只读代理。原理<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> readonlyHandlers <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">get</span><span class="token operator">:</span> readonlyGet<span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&#39;production&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Set operation on key &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token function">String</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; failed: target is readonly.</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&#39;production&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Delete operation on key &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token function">String</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; failed: target is readonly.</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>watchEffect()</code> 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</li><li><code>watchPostEffect()</code> watchEffect() 使用 flush: &#39;post&#39; 选项时的别名。</li><li><code>watchSyncEffect()</code> watchEffect() 使用 flush: &#39;sync&#39; 选项时的别名。</li><li><code>watch()</code> 侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。</li>`,5);function R(x,j){const e=o("ExternalLinkIcon");return p(),c("div",null,[d,n("ul",null,[k,n("li",null,[s("组合式Api "),n("ul",null,[n("li",null,[s("响应式 "),n("ul",null,[v,n("li",null,[m,s(" 返回一个对象的响应式代理。如果被包装的值是"),f,s("类型，该值的响应式也会保留，取值时不用"),g,s("，因为在调用"),y,s("里面的"),b,s("方法时 详见"),n("a",_,[s("reactive"),l(e)]),w]),h])])])])])])}const S=t(r,[["render",R],["__file","vue.html.vue"]]);export{S as default};

import{_ as e,o,c as t,b as d}from"./app.fc8d2037.js";const c={},l=d('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p><code>Typescript</code>在前端中运用的越来越广泛了，因此有必要去熟悉它的基本用法</p><h3 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h3><ul><li><code>tsconfig</code>中noImplicitAny表示当变量被自动推断出any时，会报出一个错误，strictNullChecks会让我们更加明确的处理<code>undefined</code>和<code>null</code></li><li>原始类型：<code>string</code>,<code>number</code>,<code>bool</code></li><li>数组<code>array</code></li><li><code>any</code>类型,对象类型，函数类型，联合类型，类型别名<code>type A=number|string</code> ,接口</li><li>类型别名和接口大部分情况下是一样的，里面最大不同是接口可以扩展，别名本身无法扩展新的属性</li><li>非空断言操作符(后缀!) 可以在不做任何检查的情况下移除<code>null</code>和<code>undefined</code></li><li><code>readonly number[]</code>和<code>ReadonlyArray&lt;number&gt;</code>是相同的</li><li>元组类型<code>type StringNumberPair = [string, number]</code>,在大部分的代码中，元组只是被创建，使用完后也不会被修改，尽可能的将元组设置为<code>raedonly</code>是个好习惯</li><li>泛型约束，先创建一个接口，然后用泛型继承它<code>interface Lengthwise {length: number;}function loggingIdentity&lt;Type extends Lengthwise&gt;(arg: Type)</code></li><li><code>const APP = [&#39;TaoBao&#39;, &#39;Tmall&#39;, &#39;Alipay&#39;] as const;type app = typeof APP[number];// type app = &quot;TaoBao&quot; | &quot;Tmall&quot; | &quot;Alipay&quot;</code></li><li>条件类型约束<code>type A&lt;T&gt;=T extends {msg:string}?T[&#39;msg&#39;]:never</code></li><li>映射修饰符：<code>type A&lt;T&gt; ={-readonly [prop in keyof T]:T[prop]}</code>删除属性中的只读元素,<code>type A&lt;T&gt; ={[prop in keyof T]-?:T[prop]}</code>删除元素中可选属性</li><li>通过<code>as</code>实现键名重新映射 <code>type AsGetter&lt;Type&gt;={[k in keyof Type as ``get${Capitalize&lt;string&amp;k&gt;}</code>]<code>:``Type[k]}</code></li><li>工具类型 <ul><li><code>Partial&lt;Type&gt;</code>可以让全部属性变成可选</li><li><code>Required&lt;Type&gt;</code> 让全部属性设置为必填</li><li><code>Readonly&lt;Type&gt;</code> 全部属性设置为只读</li><li><code>Record&lt;Keys, Type&gt;</code> 构造一个键值对象</li><li><code>Pick&lt;Type, Keys&gt;</code> 从type类型中挑选keys属性</li><li><code>Omit&lt;Type, Keys&gt;</code> 从type类型中过滤keys属性</li><li><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code> 用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型,和<code>omit</code>有点像</li><li><code>Extract&lt;Type, Union&gt;</code>,从<code>type</code>类型提取所有可以赋值给<code>union</code>的类型</li><li><code>NonNullable&lt;Type&gt;</code>从<code>type</code>中排除所有<code>null</code>,<code>undefined</code>的类型</li><li><code>Parameters&lt;Type&gt;</code> 用于根据所有<code>Type</code>中函数类型的参数构造一个元祖类型</li><li><code>ConstructorParameters&lt;Type&gt;</code>用于根据Type构造函数类型来构造一个元祖或数组类型，它产生一个带着所有参数类型的元组（或者返回never如果Type不是一个函数）</li><li><code>ReturnType&lt;Type&gt;</code> 用于构造一个含有Type函数的返回值的类型</li><li><code>ThisParameterType&lt;Type&gt;</code> 用于提取一个函数类型Type的this (opens new window)参数类型，返回unknown (opens new window)如果这个函数类型没有this参数。</li><li><code>OmitThisParameter&lt;Type&gt;</code> 用于移除一个函数类型Type的this (opens new window)参数类型。如果Type没有明确的声明this 类型，那么这个返回的结果就是Type，不然的话，就返回一个新的函数类型，基于Type，但不再有this参数。</li></ul></li></ul>',4),i=[l];function n(p,r){return o(),t("div",null,i)}const y=e(c,[["render",n],["__file","typescript.html.vue"]]);export{y as default};
